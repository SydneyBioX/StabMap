[{"path":"https://sydneybiox.github.io/StabMap/articles/stabMap_PBMC_Multiome.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"StabMap: Stabilised mosaic single cell data integration using unshared features","text":"StabMap technique performing mosaic single cell data integration. Mosaic data integration presents challenge integration data features cells shared across datasets. example, challenges arise integrating single-cell datasets measure different molecular profiles, chromatin accessibility RNA expression assays. Integrative analysis data may provide -depth profile cell, facilitating downstream analysis. read StabMap please see paper Nature Biotechnology.","code":""},{"path":"https://sydneybiox.github.io/StabMap/articles/stabMap_PBMC_Multiome.html","id":"vignette-goals","dir":"Articles","previous_headings":"Introduction","what":"Vignette Goals","title":"StabMap: Stabilised mosaic single cell data integration using unshared features","text":"vignette elaborate mosaic single cell data integration implemented StabMap package. address key goals: Mosaic Data integration 2 datasets Demonstrating cell imputation following integration Indirect mosaic data integration 3 datasets, including 2 non-overlapping datasets","code":""},{"path":"https://sydneybiox.github.io/StabMap/articles/stabMap_PBMC_Multiome.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"StabMap: Stabilised mosaic single cell data integration using unshared features","text":"tutorial work multi-assay single cell dataset, consisting ATAC gene expression data 10,032 cells. Perform exploration data.  Keep first 2,000 cells . Normalise select variable features RNA modality. Keep first 2,000 cells . Normalise select variable features ATAC modality. Create composite full data matrix concatenating.","code":"mae <- scMultiome(   \"pbmc_10x\",   mode = \"*\", dry.run = FALSE, format = \"MTX\", verbose = TRUE ) mae ## A MultiAssayExperiment object of 2 listed ##  experiments with user-defined names and respective classes. ##  Containing an ExperimentList class object of length 2: ##  [1] atac: SingleCellExperiment with 108344 rows and 10032 columns ##  [2] rna: SingleCellExperiment with 36549 rows and 10032 columns ## Functionality: ##  experiments() - obtain the ExperimentList instance ##  colData() - the primary/phenotype DataFrame ##  sampleMap() - the sample coordination DataFrame ##  `$`, `[`, `[[` - extract colData columns, subset, or experiment ##  *Format() - convert into a long or wide DataFrame ##  assays() - convert ExperimentList to a SimpleList of matrices ##  exportClass() - save data to flat files upsetSamples(mae) head(colData(mae)) ## DataFrame with 6 rows and 6 columns ##                  nCount_RNA nFeature_RNA nCount_ATAC nFeature_ATAC ##                   <integer>    <integer>   <integer>     <integer> ## AAACAGCCAAGGAATC       8380         3308       55582         13878 ## AAACAGCCAATCCCTT       3771         1896       20495          7253 ## AAACAGCCAATGCGCT       6876         2904       16674          6528 ## AAACAGCCAGTAGGTG       7614         3061       39454         11633 ## AAACAGCCAGTTTACG       3633         1691       20523          7245 ## AAACAGCCATCCAGGT       7782         3028       22412          8602 ##                                celltype broad_celltype ##                             <character>    <character> ## AAACAGCCAAGGAATC      naive CD4 T cells       Lymphoid ## AAACAGCCAATCCCTT     memory CD4 T cells       Lymphoid ## AAACAGCCAATGCGCT      naive CD4 T cells       Lymphoid ## AAACAGCCAGTAGGTG      naive CD4 T cells       Lymphoid ## AAACAGCCAGTTTACG     memory CD4 T cells       Lymphoid ## AAACAGCCATCCAGGT non-classical monocy..        Myeloid dim(experiments(mae)[[\"rna\"]]) ## [1] 36549 10032 names(experiments(mae)) ## [1] \"atac\" \"rna\" sce.rna <- experiments(mae)[[\"rna\"]]  # Normalisation sce.rna <- logNormCounts(sce.rna)  # Feature selection decomp <- modelGeneVar(sce.rna) hvgs <- rownames(decomp)[decomp$mean > 0.01 & decomp$p.value <= 0.05]  length(hvgs) ## [1] 952 sce.rna <- sce.rna[hvgs, ] dim(experiments(mae)[[\"atac\"]]) ## [1] 108344  10032 sce.atac <- experiments(mae)[[\"atac\"]]  # Normalise sce.atac <- logNormCounts(sce.atac)  # Feature selection using highly variable peaks # And adding matching peaks to genes decomp <- modelGeneVar(sce.atac) hvgs <- rownames(decomp)[decomp$mean > 0.25 &   decomp$p.value <= 0.05] length(hvgs) ## [1] 788 sce.atac <- sce.atac[hvgs, ] logcounts_all <- rbind(logcounts(sce.rna), logcounts(sce.atac)) dim(logcounts_all) ## [1]  1740 10032 assayType <- ifelse(rownames(logcounts_all) %in% rownames(sce.rna),   \"rna\", \"atac\" ) table(assayType) ## assayType ## atac  rna  ##  788  952"},{"path":"https://sydneybiox.github.io/StabMap/articles/stabMap_PBMC_Multiome.html","id":"mosaic-data-integration-with-stabmap","dir":"Articles","previous_headings":"","what":"Mosaic data integration with StabMap","title":"StabMap: Stabilised mosaic single cell data integration using unshared features","text":"simulate situation half cells correspond Multiome (RNA + ATAC features) modality, half cells correspond RNA modality. goal integrate datasets generating joint embedding cells using data, impute missing ATAC cell values RNA modality cells. Examine shared features two datasets using mosaicDataUpSet().  note shared features RNA Multiome datasets, many features observed Multiome dataset RNA - constructed. can understand mosaicDataTopology() datasets, generates igraph object, can inspected plotted. mosaicDataTopology() weighted network nodes represent dataset, edges connect nodes least one overlapping feature.  note datasets RNA Multiome share least features. StabMap requires mosaic data topology network connected, , path every pair nodes network. now aim integrate data RNA Multiome modality generating common joint embedding data using stabMap(). stabMap() integration approach aims stabilize integration single-cell data exploting non-overlapping features, cells similar biological profiles cluster. Stabilisation using non-overlapping features may important limited overlapping features informative features unknown. stabMap generates joint embedding using 3 steps: Identify mosaicDataTopology() Embed reference dataset lower dimensional space Project cells non-reference datasets onto reference dataset embedding using model traverse shortest paths mosaicDataTopology() Since Multiome data contains features, treat reference dataset. Since already examined mosaic data topology, set plot = FALSE. can reduce dimension using non-linear approaches UMAP.  see RNA Multiome cells fairly well-mixed.","code":"dataType <- setNames(   sample(c(\"RNA\", \"Multiome\"), ncol(logcounts_all),     prob = c(0.5, 0.5), replace = TRUE   ),   colnames(logcounts_all) ) table(dataType) ## dataType ## Multiome      RNA  ##     5025     5007 assay_list <- list(   RNA = logcounts_all[assayType %in% c(\"rna\"), dataType %in% c(\"RNA\")],   Multiome = logcounts_all[     assayType %in% c(\"rna\", \"atac\"), dataType %in% c(\"Multiome\")   ] )  lapply(assay_list, dim) ## $RNA ## [1]  952 5007 ##  ## $Multiome ## [1] 1740 5025 lapply(assay_list, class) ## $RNA ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" ##  ## $Multiome ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" mosaicDataUpSet(assay_list, plot = FALSE) mdt <- mosaicDataTopology(assay_list) mdt ## IGRAPH b797d9a UN-- 2 1 --  ## + attr: name (v/c), frame.color (v/c), color (v/c), label.color (v/c), ## | label.family (v/c) ## + edge from b797d9a (vertex names): ## [1] RNA--Multiome plot(mdt) stab <- stabMap(assay_list,   reference_list = c(\"Multiome\"),   plot = FALSE ) ## treating \"Multiome\" as reference ## generating embedding for path with reference \"Multiome\": \"Multiome\" ## generating embedding for path with reference \"Multiome\": \"RNA\" -> \"Multiome\" dim(stab) ## [1] 10032    50 stab[1:5, 1:5] ##                  Multiome_PC1 Multiome_PC2 Multiome_PC3 Multiome_PC4 ## AAACAGCCAATCCCTT    12.885344    -3.075968    -1.723863   -0.3561525 ## AAACAGCCAGTTTACG    11.314093    -2.344855     2.608507    1.2228681 ## AAACATGCAAGGTCCT    13.821325    -3.100703     4.755135   -0.6836924 ## AAACATGCACCGGCTA     6.287519    -2.080285   -24.802926   -0.6373922 ## AAACATGCAGCAAGTG    12.500354    -3.058831     5.358400   -2.6757611 ##                  Multiome_PC5 ## AAACAGCCAATCCCTT   -4.6468061 ## AAACAGCCAGTTTACG   -8.5576292 ## AAACATGCAAGGTCCT    6.0538837 ## AAACATGCACCGGCTA    7.1583625 ## AAACATGCAGCAAGTG   -0.1806992 stab_umap <- calculateUMAP(t(stab)) dim(stab_umap) ## [1] 10032     2 plot(stab_umap, pch = 16, cex = 0.3, col = factor(dataType[rownames(stab)]))"},{"path":"https://sydneybiox.github.io/StabMap/articles/stabMap_PBMC_Multiome.html","id":"data-imputation-after-stabmap","dir":"Articles","previous_headings":"","what":"Data imputation after StabMap","title":"StabMap: Stabilised mosaic single cell data integration using unshared features","text":"Given joint embedding, can predict missing ATAC cell values using imputeEmbedding(). use imputeEmbedding() demonstration purposes data modalities sufficient sample sizes (cells) thus cellular imputation isn’t needed. imputeEmbedding() provide data list, joint embedding output stabMap(). set Multiome cells reference RNA cells query. useful downstream visualisation interpretation.","code":"imp <- imputeEmbedding(   assay_list,   stab,   reference = colnames(assay_list[[\"Multiome\"]]),   query = colnames(assay_list[[\"RNA\"]]) )  class(imp) ## [1] \"list\" names(imp) ## [1] \"Multiome\" lapply(imp, dim) ## $Multiome ## [1] 1740 5007 lapply(assay_list, dim) ## $RNA ## [1]  952 5007 ##  ## $Multiome ## [1] 1740 5025 imp[[\"Multiome\"]][1:5, 1:5] ## 5 x 5 sparse Matrix of class \"dgCMatrix\" ##        AAACAGCCAAGGAATC AAACAGCCAATGCGCT AAACAGCCAGTAGGTG AAACAGCCATCCAGGT ## CA6            1.299581         1.338925         1.075695                . ## CNR2           .                .                .                       . ## IFNLR1         .                .                .                       . ## RCAN3          1.414502         1.553737         1.656583                . ## ZNF683         .                .                .                       . ##        AAACATGCACTTGTTC ## CA6                   . ## CNR2                  . ## IFNLR1                . ## RCAN3                 . ## ZNF683                ."},{"path":"https://sydneybiox.github.io/StabMap/articles/stabMap_PBMC_Multiome.html","id":"annotating-query-datasets-using-the-stabmap-embedding","dir":"Articles","previous_headings":"","what":"Annotating Query Datasets using the StabMap embedding","title":"StabMap: Stabilised mosaic single cell data integration using unshared features","text":"can also leverage joint embedding annotate query data. use k-nearest neighbors (KNN) based algorithm transfer cell type labels reference query dataset. demonstration treat Multiome dataset reference RNA dataset query. column data single cell experiments objects contained mae contain cell type annotations cell celltype column. first extract cell type annotations reference dataset (Multiome). classify query cells based reference dataset can use classifyEmbedding() function. provide joint embedding generated stabMap() cell type labels reference dataset classifyEmbedding() function. classifyEmbedding() returns dataframe predicted labels predicted_labels column. simulated datasets true label annotations RNA (query) cells. can evaluate well predicted annotations match true annotations use measure accuracy. Since reference query cells embedded low dimensional space can also visualise cells together. present UMAP visualisation colour coded cell types.","code":"annotation <- \"celltype\" referenceLabels <- colData(   experiments(mae)[[\"rna\"]] )[colnames(assay_list$Multiome), annotation] names(referenceLabels) <- colnames(assay_list$Multiome)  table(referenceLabels) ## referenceLabels ##  CD56 (bright) NK cells     CD56 (dim) NK cells     classical monocytes  ##                     189                     217                     987  ##    effector CD8 T cells  intermediate monocytes            MAIT T cells  ##                     205                     344                      49  ##          memory B cells      memory CD4 T cells              myeloid DC  ##                     207                     792                     105  ##           naive B cells       naive CD4 T cells       naive CD8 T cells  ##                     152                     745                     783  ## non-classical monocytes         plasmacytoid DC  ##                     199                      51 knn_out <- classifyEmbedding(   stab,   referenceLabels, ) # Extract query labels queryLabels <- colData(   experiments(mae)[[\"rna\"]] )[colnames(assay_list$RNA), annotation] names(queryLabels) <- colnames(assay_list$RNA)  acc <- mean(queryLabels == knn_out[names(queryLabels), \"predicted_labels\"]) acc ## [1] 0.9203116 # Extract reference and query cells from UMAP embedding stab_umap_ref <- stab_umap[colnames(assay_list$Multiome), ] stab_umap_query <- stab_umap[colnames(assay_list$RNA), ]  # Create UMAP for reference cells df_umap_ref <- data.frame(   x = stab_umap_ref[, 1],   y = stab_umap_ref[, 2],   cell_type = referenceLabels[rownames(stab_umap_ref)] )  p_ref <- df_umap_ref %>%   ggplot() +   aes(x = x, y = y, colour = cell_type) +   geom_point(size = 1) +   ggtitle(\"Reference cell type annotation\")  # Create UMAP for query cells df_umap_query <- data.frame(   x = stab_umap_query[, 1],   y = stab_umap_query[, 2],   cell_type = queryLabels[rownames(stab_umap_query)] )  p_query <- df_umap_query %>%   ggplot() +   aes(x = x, y = y, colour = cell_type) +   geom_point(size = 1) +   ggtitle(\"Query predicted cell types\")  grid.arrange(p_ref, p_query, ncol = 2)"},{"path":"https://sydneybiox.github.io/StabMap/articles/stabMap_PBMC_Multiome.html","id":"indirect-mosaic-data-integration-with-stabmap","dir":"Articles","previous_headings":"","what":"Indirect mosaic data integration with StabMap","title":"StabMap: Stabilised mosaic single cell data integration using unshared features","text":"StabMap flexible framework mosaic data integration, can still integrate data even pairs datasets share features . long path connecting datasets along mosaic data topology (underlying assumption shared features along paths contain information), can extract meaningful joint embeddings. demonstrate , simulate three data sources. Using mosaicDataUpSet(), note shared features ATAC RNA datasets. integration might able match features extracting genomic positions making “central dogma assumption”, , peaks associated genomic position overlapping gene correspond positive gene expression gene. However, using stabMap() need make assumption data integration performed.  can understand mosaicDataTopology() datasets, generates igraph object, can inspected plotted.  StabMap requires mosaic data topology network connected, , path every pair nodes network. ATAC RNA overlapping features, since path RNA ATAC (via Multiome), can proceed. now generate common joint embedding data using stabMap(). Since Multiome data contains features, treat reference dataset. Since already examined mosaic data topology, set plot = FALSE. can reduce dimension using non-linear approaches UMAP.  see RNA, ATAC Multiome cells fairly well-mixed. Colouring cells original cell type, can also see mosaic data integration meaningful.","code":"dataTypeIndirect <- setNames(   sample(c(\"RNA\", \"Multiome\", \"ATAC\"), ncol(logcounts_all),     prob = c(0.3, 0.3, 0.3), replace = TRUE   ),   colnames(logcounts_all) ) table(dataTypeIndirect) ## dataTypeIndirect ##     ATAC Multiome      RNA  ##     3446     3342     3244 assay_list_indirect <- list(   RNA = logcounts_all[assayType %in% c(\"rna\"), dataTypeIndirect %in% c(\"RNA\")],   Multiome = logcounts_all[     assayType %in% c(\"rna\", \"atac\"), dataTypeIndirect %in% c(\"Multiome\")   ],   ATAC = logcounts_all[     assayType %in% c(\"atac\"), dataTypeIndirect %in% c(\"ATAC\")   ] )  lapply(assay_list_indirect, dim) ## $RNA ## [1]  952 3244 ##  ## $Multiome ## [1] 1740 3342 ##  ## $ATAC ## [1]  788 3446 lapply(assay_list_indirect, class) ## $RNA ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" ##  ## $Multiome ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" ##  ## $ATAC ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" mosaicDataUpSet(assay_list_indirect, plot = FALSE) mdt_indirect <- mosaicDataTopology(assay_list_indirect) mdt_indirect ## IGRAPH d36436c UN-- 3 2 --  ## + attr: name (v/c), frame.color (v/c), color (v/c), label.color (v/c), ## | label.family (v/c) ## + edges from d36436c (vertex names): ## [1] RNA     --Multiome Multiome--ATAC plot(mdt_indirect) stab_indirect <- stabMap(assay_list_indirect,   reference_list = c(\"Multiome\"),   plot = FALSE ) ## treating \"Multiome\" as reference ## generating embedding for path with reference \"Multiome\": \"Multiome\" ## generating embedding for path with reference \"Multiome\": \"RNA\" -> \"Multiome\" ## generating embedding for path with reference \"Multiome\": \"ATAC\" -> \"Multiome\" dim(stab_indirect) ## [1] 10032    50 stab_indirect[1:5, 1:5] ##                  Multiome_PC1 Multiome_PC2 Multiome_PC3 Multiome_PC4 ## AAACAGCCAATCCCTT    12.742178    3.0909138     1.757548    0.2695901 ## AAACAGCCAATGCGCT    12.708202    1.5955101    -6.170703    0.6596048 ## AAACATGCAAGGTCCT    13.646213    2.9647341    -4.846989    0.5665123 ## AAACATGCACCGGCTA     6.143255    2.1167652    24.572169    0.4845784 ## AAACATGCACTTGTTC     9.236392    0.8773643    -3.033358    0.2705357 ##                  Multiome_PC5 ## AAACAGCCAATCCCTT    4.4791329 ## AAACAGCCAATGCGCT   -2.3739650 ## AAACATGCAAGGTCCT   -6.5805017 ## AAACATGCACCGGCTA   -7.6081000 ## AAACATGCACTTGTTC    0.2939029 stab_indirect_umap <- calculateUMAP(t(stab_indirect)) dim(stab_indirect_umap) ## [1] 10032     2 plot(stab_indirect_umap,   pch = 16, cex = 0.3,   col = factor(dataTypeIndirect[rownames(stab_indirect)]) ) cellType <- setNames(mae$celltype, colnames(mae[[1]]))  plot(stab_indirect_umap,   pch = 16, cex = 0.3,   col = factor(cellType[rownames(stab_indirect)]) ) sessionInfo() ## R version 4.4.1 (2024-06-14) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] HDF5Array_1.32.0            rhdf5_2.48.0                ##  [3] DelayedArray_0.30.1         SparseArray_1.4.8           ##  [5] S4Arrays_1.4.1              abind_1.4-5                 ##  [7] Matrix_1.7-0                gridExtra_2.3               ##  [9] SingleCellMultiModal_1.16.0 MultiAssayExperiment_1.30.3 ## [11] scran_1.32.0                scater_1.32.1               ## [13] ggplot2_3.5.1               scuttle_1.14.0              ## [15] SingleCellExperiment_1.26.0 SummarizedExperiment_1.34.0 ## [17] Biobase_2.64.0              GenomicRanges_1.56.1        ## [19] GenomeInfoDb_1.40.1         IRanges_2.38.1              ## [21] S4Vectors_0.42.1            BiocGenerics_0.50.0         ## [23] MatrixGenerics_1.16.0       matrixStats_1.3.0           ## [25] magrittr_2.0.3              StabMap_0.99.3              ## [27] BiocStyle_2.32.1            ##  ## loaded via a namespace (and not attached): ##   [1] jsonlite_1.8.8            ggbeeswarm_0.7.2          ##   [3] magick_2.8.4              farver_2.1.2              ##   [5] rmarkdown_2.27            fs_1.6.4                  ##   [7] zlibbioc_1.50.0           ragg_1.3.2                ##   [9] vctrs_0.6.5               memoise_2.0.1             ##  [11] DelayedMatrixStats_1.26.0 htmltools_0.5.8.1         ##  [13] BiocBaseUtils_1.6.0       AnnotationHub_3.12.0      ##  [15] curl_5.2.1                BiocNeighbors_1.22.0      ##  [17] Rhdf5lib_1.26.0           sass_0.4.9                ##  [19] bslib_0.8.0               desc_1.4.3                ##  [21] plyr_1.8.9                cachem_1.1.0              ##  [23] igraph_2.0.3              mime_0.12                 ##  [25] lifecycle_1.0.4           pkgconfig_2.0.3           ##  [27] rsvd_1.0.5                R6_2.5.1                  ##  [29] fastmap_1.2.0             GenomeInfoDbData_1.2.12   ##  [31] digest_0.6.36             colorspace_2.1-1          ##  [33] AnnotationDbi_1.66.0      dqrng_0.4.1               ##  [35] irlba_2.3.5.1             ExperimentHub_2.12.0      ##  [37] textshaping_0.4.0         RSQLite_2.3.7             ##  [39] beachmat_2.20.0           labeling_0.4.3            ##  [41] filelock_1.0.3            fansi_1.0.6               ##  [43] httr_1.4.7                compiler_4.4.1            ##  [45] bit64_4.0.5               withr_3.0.0               ##  [47] BiocParallel_1.38.0       viridis_0.6.5             ##  [49] DBI_1.2.3                 UpSetR_1.4.0              ##  [51] highr_0.11                rappdirs_0.3.3            ##  [53] rjson_0.2.21              bluster_1.14.0            ##  [55] tools_4.4.1               vipor_0.4.7               ##  [57] beeswarm_0.4.0            glue_1.7.0                ##  [59] rhdf5filters_1.16.0       grid_4.4.1                ##  [61] cluster_2.1.6             generics_0.1.3            ##  [63] gtable_0.3.5              BiocSingular_1.20.0       ##  [65] ScaledMatrix_1.12.0       metapod_1.12.0            ##  [67] utf8_1.2.4                XVector_0.44.0            ##  [69] RcppAnnoy_0.0.22          ggrepel_0.9.5             ##  [71] BiocVersion_3.19.1        pillar_1.9.0              ##  [73] limma_3.60.4              dplyr_1.1.4               ##  [75] BiocFileCache_2.12.0      lattice_0.22-6            ##  [77] bit_4.0.5                 tidyselect_1.2.1          ##  [79] locfit_1.5-9.10           Biostrings_2.72.1         ##  [81] knitr_1.48                bookdown_0.40             ##  [83] edgeR_4.2.1               xfun_0.46                 ##  [85] statmod_1.5.0             UCSC.utils_1.0.0          ##  [87] yaml_2.3.10               evaluate_0.24.0           ##  [89] codetools_0.2-20          tibble_3.2.1              ##  [91] BiocManager_1.30.23       cli_3.6.3                 ##  [93] uwot_0.2.2                systemfonts_1.1.0         ##  [95] munsell_0.5.1             jquerylib_0.1.4           ##  [97] Rcpp_1.0.13               dbplyr_2.5.0              ##  [99] png_0.1-8                 parallel_4.4.1            ## [101] pkgdown_2.1.0             blob_1.2.4                ## [103] sparseMatrixStats_1.16.0  SpatialExperiment_1.14.0  ## [105] slam_0.1-51               viridisLite_0.4.2         ## [107] scales_1.3.0              purrr_1.0.2               ## [109] crayon_1.5.3              rlang_1.1.4               ## [111] KEGGREST_1.44.1"},{"path":"https://sydneybiox.github.io/StabMap/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Shila Ghazanfar. Author, maintainer, contributor. Aiden Jin. Contributor. Nicholas Robertson. Contributor.","code":""},{"path":"https://sydneybiox.github.io/StabMap/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ghazanfar S (2024). StabMap: Stabilised mosaic single cell data integration using unshared features. R package version 0.99.3, https://sydneybiox.github.io/StabMap/, https://sydneybiox.github.io/StabMap.","code":"@Manual{,   title = {StabMap: Stabilised mosaic single cell data integration using unshared features},   author = {Shila Ghazanfar},   year = {2024},   note = {R package version 0.99.3, https://sydneybiox.github.io/StabMap/},   url = {https://sydneybiox.github.io/StabMap}, }"},{"path":[]},{"path":"https://sydneybiox.github.io/StabMap/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Stabilised mosaic single cell data integration using unshared features","text":"Install StabMap via Bioconductor Install Github version StabMap","code":"library(BiocManager) BiocManager::install(\"StabMap\") BiocManager::install(\"SydneyBioX/StabMap\")"},{"path":"https://sydneybiox.github.io/StabMap/index.html","id":"vignette","dir":"","previous_headings":"","what":"Vignette","title":"Stabilised mosaic single cell data integration using unshared features","text":"can find vignette showing StabMap can used PBMC single cell data website.","code":""},{"path":"https://sydneybiox.github.io/StabMap/index.html","id":"method","dir":"","previous_headings":"","what":"Method","title":"Stabilised mosaic single cell data integration using unshared features","text":"Figure: StabMap method overview. . Example mosaic data integration displaying observed data matrices varying overlap features among datasets. Datasets summarised using mosaic data topology (MDT). Cells projected onto common StabMap embedding across cells. b. Cells datasets projected onto reference space (dark red) traversing shortest paths along MDT. Blue cells projected directly onto reference space, whereas yellow cells first projected onto space defined blue cells, followed projection dark red space. cells combined yield common StabMap embedding. c. process described panel b performed various selected reference datasets (default = ), followed L2-norm re-weighting provided user (default = equal weight). reweighted embeddings concatenated form StabMap embedding multiple reference datasets, can used downstream analysis tasks.","code":""},{"path":"https://sydneybiox.github.io/StabMap/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Stabilised mosaic single cell data integration using unshared features","text":"shila.ghazanfar <> sydney.edu.au, marioni <> ebi.ac.uk.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/adaptiveKNN.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive k-Nearest Neighbour Classification — adaptiveKNN","title":"Adaptive k-Nearest Neighbour Classification — adaptiveKNN","text":"Adaptive k-Nearest Neighbour Classification k-nearest neighbour matrix, given class labels local k values training data","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/adaptiveKNN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptive k-Nearest Neighbour Classification — adaptiveKNN","text":"","code":"adaptiveKNN(knn, class, k_local)"},{"path":"https://sydneybiox.github.io/StabMap/reference/adaptiveKNN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptive k-Nearest Neighbour Classification — adaptiveKNN","text":"knn k-nearest neighbour matrix, giving indices training set query closest . Rows query cells, columns NNs. Typically output using BiocNeighbors::queryKNN(,,k = max(k_local)). class labels associated training set. k_local integer vector length training set, giving local k use k_local given single integer, value used k observations.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/adaptiveKNN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptive k-Nearest Neighbour Classification — adaptiveKNN","text":"character vector classifications test set.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/adaptiveKNN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptive k-Nearest Neighbour Classification — adaptiveKNN","text":"","code":"# Generate example data data <- matrix(rpois(10 * 20, 10), 10, 20) # 10 genes, 20 cells data_2 <- matrix(rpois(10 * 30, 10), 10, 30) # 10 genes, 30 cells  # Generate error matrix for k_local E <- matrix(runif(100), 20, 5) colnames(E) <- paste0(\"K_\", 1:5)  # Define training class labels and adaptive k-values class <- factor(rep(letters[1:2], each = 10)) k_local <- getAdaptiveK(E, labels = class)  knn <- BiocNeighbors::queryKNN(   t(data), t(data_2),   k = max(as.numeric(gsub(\"K_\", \"\", k_local))) )$index #> Warning: detected tied distances to neighbors, see ?'BiocNeighbors-ties'  # Adaptive KNN classification test <- adaptiveKNN(   knn, class, as.numeric(gsub(\"K_\", \"\", k_local)) )"},{"path":"https://sydneybiox.github.io/StabMap/reference/allEqual.html","id":null,"dir":"Reference","previous_headings":"","what":"allEqual — allEqual","title":"allEqual — allEqual","text":"Checks vector equal first element","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/allEqual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"allEqual — allEqual","text":"","code":"allEqual(x)"},{"path":"https://sydneybiox.github.io/StabMap/reference/allEqual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"allEqual — allEqual","text":"x vector.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/allEqual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"allEqual — allEqual","text":"logical whether vector equal first element.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/buildLabelsDataFrame.html","id":null,"dir":"Reference","previous_headings":"","what":"buildLabelsDataFrame — buildLabelsDataFrame","title":"buildLabelsDataFrame — buildLabelsDataFrame","text":"Build dataframe output `classifyEmbedding`","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/buildLabelsDataFrame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"buildLabelsDataFrame — buildLabelsDataFrame","text":"","code":"buildLabelsDataFrame(labels, resubstituted_labels, k_adaptive)"},{"path":"https://sydneybiox.github.io/StabMap/reference/buildLabelsDataFrame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"buildLabelsDataFrame — buildLabelsDataFrame","text":"labels named character vector true labels. resubstituted_labels named character vector predicted labels. k_adaptive named vector k-values, single integer fixed.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/buildLabelsDataFrame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"buildLabelsDataFrame — buildLabelsDataFrame","text":"dataframe rows resubstituted_labels columns input_labels, predicted_labels, resubstituted_labels.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/classifyEmbedding.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive k-Nearest Neighbour Classification using the StabMap joint embedding — classifyEmbedding","title":"Adaptive k-Nearest Neighbour Classification using the StabMap joint embedding — classifyEmbedding","text":"Performs adaptive k-nearest neighbour classification discrete labels training set query set, leveraging StabMap joint embedding. training labels defined `labels`, rows embedding treated testing set.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/classifyEmbedding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptive k-Nearest Neighbour Classification using the StabMap joint embedding — classifyEmbedding","text":"","code":"classifyEmbedding(   coords,   labels,   type = c(\"uniform_fixed\", \"adaptive_labels\", \"adaptive_local\", \"uniform_optimised\"),   k_values = 5,   error_measure = c(\"simple_error\", \"balanced_error\"),   adaptive_nFold = 2,   adaptive_nRep = 5,   adaptive_local_nhood = 100,   adaptive_local_smooth = 10,   verbose = TRUE )"},{"path":"https://sydneybiox.github.io/StabMap/reference/classifyEmbedding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptive k-Nearest Neighbour Classification using the StabMap joint embedding — classifyEmbedding","text":"coords cells (rows) x dimensions data matrix, euclidean distances calculated KNN classification. Must rownames. Typically, output `stabMap()`. labels named character vector labels training set. type character type adaptive KNN classification used. Must one \"adaptive_local\", \"adaptive_labels\", \"uniform_optimised\", \"uniform_fixed\". Default \"uniform_fixed\". k_values numeric vector potential k values. type \"uniform_fixed\", first value k_values used. Default 5. error_measure error type use selection best k. Must one \"simple_error\" \"balanced_error\". \"simple_error\" weights cells equally. \"balanced_error\" weights error `labels` factors. affects error type type == \"uniform_optimised\". adaptive_nFold number folds adaptive selection cross-validation. adaptive_nRep number repetitions adaptive selection cross-validation. adaptive_local_nhood neighbourhood size optimising locally. adaptive_local_smooth number neighbours use smoothing locally. verbose Logical whether print repetition fold number adaptive selection cross-validation.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/classifyEmbedding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptive k-Nearest Neighbour Classification using the StabMap joint embedding — classifyEmbedding","text":"dataframe rows coords, rownames. Columns : input_labels training labels provided `labels` (NA used labels testing set), resubstituted_labels predicted labels rows (including training data), predicted_labels predicted labels testing set true labels provided `labels` training set, k adaptive k value used row training set.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/classifyEmbedding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptive k-Nearest Neighbour Classification using the StabMap joint embedding — classifyEmbedding","text":"","code":"set.seed(100) # Simulate coordinates coords <- matrix(rnorm(1000), 100, 10) rownames(coords) <- paste0(\"cell_\", 1:nrow(coords))  # Define labels of the first 50 cells labels <- rep(paste0(\"type_\", letters[1:5]), 10) names(labels) <- rownames(coords)[1:length(labels)]  # Uniform fixed KNN classification knn_out <- classifyEmbedding(   coords, labels,   type = \"uniform_fixed\", k_values = 5 ) table(knn_out$predicted_labels) #>  #> type_a type_b type_c type_d type_e  #>     23     18     24     19     16   # Adaptive KNN classification using local error knn_out <- classifyEmbedding( coords, labels, type = \"adaptive_local\", k_values = 2:3, adaptive_nFold = 5, adaptive_nRep = 10 ) #> Rep 1 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 2 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 3 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 4 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 5 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 6 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 7 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 8 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 9 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 10 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Warning: 'k' capped at the number of observations table(knn_out$predicted_labels) #>  #> type_a type_b type_c type_d type_e  #>     24     14     23     18     21   knn_out <- classifyEmbedding(   coords, labels,   type = \"adaptive_labels\",   k_values = 2:3,   adaptive_nFold = 5,   adaptive_nRep = 10 ) #> Rep 1 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 2 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 3 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 4 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 5 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 6 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 7 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 8 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 9 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 #> Rep 10 of 10 #> Fold 1 of 5 #> Fold 2 of 5 #> Fold 3 of 5 #> Fold 4 of 5 #> Fold 5 of 5 table(knn_out$predicted_labels) #>  #> type_a type_b type_c type_d type_e  #>     23     16     22     19     20   # Adaptive KNN classification using uniform optimised with balanced error knn_out <- classifyEmbedding(   coords, labels,   type = \"uniform_optimised\",   k_values = 2:3,   adaptive_nFold = 3,   adaptive_nRep = 10,   error_measure = \"balanced_error\" ) #> Rep 1 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 2 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 3 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 4 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 5 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 6 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 7 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 8 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 9 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 #> Rep 10 of 10 #> Fold 1 of 3 #> Fold 2 of 3 #> Fold 3 of 3 table(knn_out$predicted_labels) #>  #> type_a type_b type_c type_d type_e  #>     23     17     22     19     19"},{"path":"https://sydneybiox.github.io/StabMap/reference/combineBinaryErrors.html","id":null,"dir":"Reference","previous_headings":"","what":"combineBinaryErrors — combineBinaryErrors","title":"combineBinaryErrors — combineBinaryErrors","text":"Combines binary error matrices averaging error values across matrices, entry (row column combination)","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/combineBinaryErrors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"combineBinaryErrors — combineBinaryErrors","text":"","code":"combineBinaryErrors(E_list)"},{"path":"https://sydneybiox.github.io/StabMap/reference/combineBinaryErrors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"combineBinaryErrors — combineBinaryErrors","text":"E_list list containing matrices. matrix must number columns (k-values) contain rownames (cells).","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/combineBinaryErrors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"combineBinaryErrors — combineBinaryErrors","text":"sparse error matrix.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/dot-runOps.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a sequence of binary operations — .runOps","title":"Run a sequence of binary operations — .runOps","text":"Run sequence binary operations","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/dot-runOps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a sequence of binary operations — .runOps","text":"","code":".runOps(obj, ops, leftToRight = TRUE)"},{"path":"https://sydneybiox.github.io/StabMap/reference/dot-runOps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a sequence of binary operations — .runOps","text":"obj list objects. ops list operations (length 1 less `obj`). leftToRight logical whether operations performed order left right (default), right left.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/dot-runOps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a sequence of binary operations — .runOps","text":"matrix array output sequence binary operations","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getAdaptiveK.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive k selection for KNN classification — getAdaptiveK","title":"Adaptive k selection for KNN classification — getAdaptiveK","text":"Given error matrix, identify k maximises accuracy cells belonging provided labelling/grouping. labelling given, expect cell-cell similarity network identify k maximises accuracy cells within neighbourhood. neither given, simply treat cells labelling/grouping","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getAdaptiveK.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptive k selection for KNN classification — getAdaptiveK","text":"","code":"getAdaptiveK(E, labels = NULL, local = NULL, outputPerCell = TRUE, ...)"},{"path":"https://sydneybiox.github.io/StabMap/reference/getAdaptiveK.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptive k selection for KNN classification — getAdaptiveK","text":"E error matrix rows corresponding cells columns corresponding candidate k values, values corresponding error values (either binary single classification, continuous multiple classification). labels Group labels cells. local neighbourhood index representation, typically output using BiocNeighbors::findKNN(). outputPerCell Logical whether return adaptive k cell, just label type (used labels given). ... Includes return_colnames, whether give colnames best selected, just index, default TRUE.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getAdaptiveK.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptive k selection for KNN classification — getAdaptiveK","text":"Vector adaptive k values.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getAdaptiveK.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptive k selection for KNN classification — getAdaptiveK","text":"","code":"E <- matrix(runif(100), 20, 5) colnames(E) <- paste0(\"K_\", 1:5)  # generate cell labels labels <- factor(rep(letters[1:2], each = 10))  # generate nearest neighbourhood index representation data <- matrix(rpois(10 * 20, 10), 10, 20) # 10 genes, 20 cells local <- BiocNeighbors::findKNN(t(data), k = 5, get.distance = FALSE)$index #> Warning: detected tied distances to neighbors, see ?'BiocNeighbors-ties'  best_k_labels <- getAdaptiveK(E,   labels = labels ) best_k_local <- getAdaptiveK(E,   local = local )"},{"path":"https://sydneybiox.github.io/StabMap/reference/getArgMin.html","id":null,"dir":"Reference","previous_headings":"","what":"getArgMin — getArgMin","title":"getArgMin — getArgMin","text":"row matrix calculate first index gives minimum value","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getArgMin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getArgMin — getArgMin","text":"","code":"getArgMin(M, return_colnames = TRUE, identicalNA = TRUE)"},{"path":"https://sydneybiox.github.io/StabMap/reference/getArgMin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getArgMin — getArgMin","text":"M matrix. return_colnames Logical whether return column names matrix (default TRUE). Otherwise return index. identicalNA Logical whether return NA values row identical (default TRUE).","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getArgMin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getArgMin — getArgMin","text":"vector containing first index column name minimum values row matrix.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBestColumn.html","id":null,"dir":"Reference","previous_headings":"","what":"getBestColumn — getBestColumn","title":"getBestColumn — getBestColumn","text":"Identifies index column matrix minimum mean. balanced_labels given calculate balanced mean","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBestColumn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getBestColumn — getBestColumn","text":"","code":"getBestColumn(E, balanced_labels = NULL)"},{"path":"https://sydneybiox.github.io/StabMap/reference/getBestColumn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getBestColumn — getBestColumn","text":"E error matrix. balanced_labels Class labels row (cell) E.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBestColumn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getBestColumn — getBestColumn","text":"index best performing column E","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBinaryError.html","id":null,"dir":"Reference","previous_headings":"","what":"getBinaryError — getBinaryError","title":"getBinaryError — getBinaryError","text":"potential k values, generate binary error matrix KNN label classification","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBinaryError.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getBinaryError — getBinaryError","text":"","code":"getBinaryError(knn, k_values, class_train, class_true)"},{"path":"https://sydneybiox.github.io/StabMap/reference/getBinaryError.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getBinaryError — getBinaryError","text":"knn k-nearest neighbour matrix, giving indices training set query closest . Rows query cells, columns NNs, large value. Typically output using BiocNeighbors::queryKNN(,,k = max(k_values)). k_values integer vector values k consider extracting accuracy. k_values names pass colnames E. class_train factor character vector classes corresponds indices given within knn. class_true factor character vector corresponds rows knn. class_true names pass rownames E.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBinaryError.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getBinaryError — getBinaryError","text":"sparse binary error matrix.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBinaryErrorFromPredictions.html","id":null,"dir":"Reference","previous_headings":"","what":"getBinaryErrorFromPredictions — getBinaryErrorFromPredictions","title":"getBinaryErrorFromPredictions — getBinaryErrorFromPredictions","text":"Compute binary error predicted labels true labels","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBinaryErrorFromPredictions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getBinaryErrorFromPredictions — getBinaryErrorFromPredictions","text":"","code":"getBinaryErrorFromPredictions(pred, labels)"},{"path":"https://sydneybiox.github.io/StabMap/reference/getBinaryErrorFromPredictions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getBinaryErrorFromPredictions — getBinaryErrorFromPredictions","text":"pred matrix class label predictions. labels named vector true labels.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getBinaryErrorFromPredictions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getBinaryErrorFromPredictions — getBinaryErrorFromPredictions","text":"sparse binary error matrix.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getModeFirst.html","id":null,"dir":"Reference","previous_headings":"","what":"getModeFirst — getModeFirst","title":"getModeFirst — getModeFirst","text":"Identify mode x first index","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getModeFirst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getModeFirst — getModeFirst","text":"","code":"getModeFirst(x, first)"},{"path":"https://sydneybiox.github.io/StabMap/reference/getModeFirst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getModeFirst — getModeFirst","text":"x character factor. first integer.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getModeFirst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getModeFirst — getModeFirst","text":"character mode x.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getQueryK.html","id":null,"dir":"Reference","previous_headings":"","what":"getQueryK — getQueryK","title":"getQueryK — getQueryK","text":"cell query data, use 1NN's adaptive k value (reference data) identify local best k value","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getQueryK.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getQueryK — getQueryK","text":"","code":"getQueryK(knn, k_local)"},{"path":"https://sydneybiox.github.io/StabMap/reference/getQueryK.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getQueryK — getQueryK","text":"knn k-nearest neighbour matrix, giving indices training set query closest . Rows query cells, columns NNs, large value. Typically output using BiocNeighbors::queryKNN(,,k = max(k_local)). k_local integer vector length reference set, giving local k use. k_local given single integer, value used k observations.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/getQueryK.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getQueryK — getQueryK","text":"integer vector local k use query cell.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/gm_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"gm_mean — gm_mean","title":"gm_mean — gm_mean","text":"Calculate geometric mean","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/gm_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gm_mean — gm_mean","text":"","code":"gm_mean(x, na.rm = TRUE)"},{"path":"https://sydneybiox.github.io/StabMap/reference/gm_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gm_mean — gm_mean","text":"x vector. na.rm logical value indicating whether NA values stripped calculating geometric mean.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/gm_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gm_mean — gm_mean","text":"numeric.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-pred-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary operator for model predictions on data — %pred%","title":"Binary operator for model predictions on data — %pred%","text":"function performs model predictions via predict function column data.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-pred-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary operator for model predictions on data — %pred%","text":"","code":"data %pred% models"},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-pred-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binary operator for model predictions on data — %pred%","text":"data matrix rows corresponding features, columns corresponding cells/observations models list univariate outcome models features explanatory variables","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-pred-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binary operator for model predictions on data — %pred%","text":"matrix rows equal length(models) columns corresponding cells/observations","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-projpred-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Project and/or predict data using feature weights or a LDA model object — %projpred%","title":"Project and/or predict data using feature weights or a LDA model object — %projpred%","text":"function takes data matrix , depending class b, projects data using feature weights, predicts new values using linear discriminant analysis (LDA) model object, .","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-projpred-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project and/or predict data using feature weights or a LDA model object — %projpred%","text":"","code":"a %projpred% b"},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-projpred-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project and/or predict data using feature weights or a LDA model object — %projpred%","text":"matrix colnames specified b matrix rownames specified, lda model object, list containing matrix /lda model object.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-projpred-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project and/or predict data using feature weights or a LDA model object — %projpred%","text":"matrix","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-times-1-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Sorted matrix multiplication with intercept column — %*1%","title":"Sorted matrix multiplication with intercept column — %*1%","text":"function first binds column filled 1s named intercept , performs rownames colnames-aware (%**%) matrix multiplication b.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-times-1-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sorted matrix multiplication with intercept column — %*1%","text":"","code":"a %*1% b"},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-times-1-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sorted matrix multiplication with intercept column — %*1%","text":"matrix rownames specified b matrix colnames specified","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-times-1-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sorted matrix multiplication with intercept column — %*1%","text":"matrix","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-times-times-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Sorted matrix multiplication — %**%","title":"Sorted matrix multiplication — %**%","text":"function multiplies two matrices first reorders rows second matrix match columns first matrix","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-times-times-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sorted matrix multiplication — %**%","text":"","code":"X %**% Y"},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-times-times-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sorted matrix multiplication — %**%","text":"X matrix colnames specified. Y matrix rownames specified. Alternatively, list assumed contain two objects, matrix rownames specified, vector scaling values subtraction.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/grapes-times-times-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sorted matrix multiplication — %**%","text":"matrix","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/imputeEmbedding.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute values using StabMap joint embedding — imputeEmbedding","title":"Impute values using StabMap joint embedding — imputeEmbedding","text":"Performs naive imputation values list mosaic data joint embedding StabMap.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/imputeEmbedding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute values using StabMap joint embedding — imputeEmbedding","text":"","code":"imputeEmbedding(   assay_list,   embedding,   reference = Reduce(union, lapply(assay_list, colnames)),   query = Reduce(union, lapply(assay_list, colnames)),   neighbours = 5,   fun = mean )"},{"path":"https://sydneybiox.github.io/StabMap/reference/imputeEmbedding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute values using StabMap joint embedding — imputeEmbedding","text":"assay_list List mosaic data perform imputation. embedding Joint embedding extract nearest neighbour relationships. reference Character vector cell names treat reference cells. query Character vector cell names treat query cells. neighbours Number nearest neighbours consider (default 5). fun function (default `mean`) aggregate nearest neighbours' imputed values.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/imputeEmbedding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute values using StabMap joint embedding — imputeEmbedding","text":"List containing imputed values assay_list data matrix contains reference cells.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/imputeEmbedding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute values using StabMap joint embedding — imputeEmbedding","text":"","code":"set.seed(2021) assay_list <- mockMosaicData() lapply(assay_list, dim) #> $D1 #> [1] 150  50 #>  #> $D2 #> [1] 150  50 #>  #> $D3 #> [1] 150  50 #>   # stabMap out <- stabMap(assay_list,   ncomponentsReference = 20,   ncomponentsSubset = 20 ) #> treating \"D1\" as reference #> generating embedding for path with reference \"D1\": \"D1\" #> generating embedding for path with reference \"D1\": \"D2\" -> \"D1\" #> generating embedding for path with reference \"D1\": \"D3\" -> \"D2\" -> \"D1\" #> treating \"D2\" as reference #> generating embedding for path with reference \"D2\": \"D2\" #> generating embedding for path with reference \"D2\": \"D1\" -> \"D2\" #> generating embedding for path with reference \"D2\": \"D3\" -> \"D2\" #> treating \"D3\" as reference #> generating embedding for path with reference \"D3\": \"D3\" #> generating embedding for path with reference \"D3\": \"D2\" -> \"D3\" #> generating embedding for path with reference \"D3\": \"D1\" -> \"D2\" -> \"D3\"   # impute values imp <- imputeEmbedding(assay_list, out)  # inspect the imputed values lapply(imp, dim) #> $D1 #> [1] 150 150 #>  #> $D2 #> [1] 150 150 #>  #> $D3 #> [1] 150 150 #>  imp[[1]][1:5, 1:5] #>          D1_cell_1   D1_cell_2  D1_cell_3   D1_cell_4   D1_cell_5 #> gene_1  0.50687450 -0.77149007 -0.2982274 -0.72078317 -0.12148316 #> gene_2  0.05829149 -0.05286518 -0.1375450  0.02383978 -0.35894336 #> gene_3  1.21645830  0.05262619  0.7272864  0.18519759  0.60755035 #> gene_4 -0.49139466  0.23012490  0.1569971 -0.12349555 -0.00984099 #> gene_5 -0.04233858 -0.33526072 -0.2985623 -0.43112877 -0.13828083"},{"path":"https://sydneybiox.github.io/StabMap/reference/isUnequal.html","id":null,"dir":"Reference","previous_headings":"","what":"isUnequal — isUnequal","title":"isUnequal — isUnequal","text":"Checks elements 2 vectors unequal","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/isUnequal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"isUnequal — isUnequal","text":"","code":"isUnequal(x, y)"},{"path":"https://sydneybiox.github.io/StabMap/reference/isUnequal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"isUnequal — isUnequal","text":"x vector. y vector.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/isUnequal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"isUnequal — isUnequal","text":"integer vector. 1 unequal. 0 equal","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mockMosaicData.html","id":null,"dir":"Reference","previous_headings":"","what":"mockMosaicData — mockMosaicData","title":"mockMosaicData — mockMosaicData","text":"Mock mosaic data list using simulated data, use documentation examples.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mockMosaicData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mockMosaicData — mockMosaicData","text":"","code":"mockMosaicData(   names = c(\"D1\", \"D2\", \"D3\"),   ncells = c(50, 50, 50),   ngenes = list(1:150, 76:225, 151:300),   fun = \"rnorm\",   ... )"},{"path":"https://sydneybiox.github.io/StabMap/reference/mockMosaicData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mockMosaicData — mockMosaicData","text":"names character vector mock datasets. ncells integer vector cells mock dataset. ngenes list containing integer vectors features measured mock dataset. fun name function simulate data, default \"rnorm\". ... arguments passed `fun`.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mockMosaicData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mockMosaicData — mockMosaicData","text":"assay_list list data matrices rownames (features) specified.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mockMosaicData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"mockMosaicData — mockMosaicData","text":"","code":"set.seed(2021) assay_list <- mockMosaicData() lapply(assay_list, dim) #> $D1 #> [1] 150  50 #>  #> $D2 #> [1] 150  50 #>  #> $D3 #> [1] 150  50 #>   # simulate data from another distribution assay_list <- mockMosaicData(fun = \"rnbinom\", size = 5, prob = 0.5) lapply(assay_list, dim) #> $D1 #> [1] 150  50 #>  #> $D2 #> [1] 150  50 #>  #> $D3 #> [1] 150  50 #>"},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataTopology.html","id":null,"dir":"Reference","previous_headings":"","what":"mosaicDataTopology — mosaicDataTopology","title":"mosaicDataTopology — mosaicDataTopology","text":"Generate mosaic data topology network igraph object.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataTopology.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mosaicDataTopology — mosaicDataTopology","text":"","code":"mosaicDataTopology(assay_list)"},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataTopology.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mosaicDataTopology — mosaicDataTopology","text":"assay_list list data matrices rownames (features) specified.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataTopology.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mosaicDataTopology — mosaicDataTopology","text":"igraph weighted network nodes corresponding assay_list elements, edges present matrices share least one rowname. Edge weights correspond number shared rownames among data matrices.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataTopology.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"mosaicDataTopology — mosaicDataTopology","text":"","code":"set.seed(2021) assay_list <- mockMosaicData() mdt <- mosaicDataTopology(assay_list) mdt #> IGRAPH 7f5fa91 UN-- 3 2 --  #> + attr: name (v/c), frame.color (v/c), color (v/c), label.color (v/c), #> | label.family (v/c) #> + edges from 7f5fa91 (vertex names): #> [1] D1--D2 D2--D3 plot(mdt)"},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataUpSet.html","id":null,"dir":"Reference","previous_headings":"","what":"mosaicDataUpSet — mosaicDataUpSet","title":"mosaicDataUpSet — mosaicDataUpSet","text":"Plots feature overlaps mosaic data UpSet plot.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataUpSet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mosaicDataUpSet — mosaicDataUpSet","text":"","code":"mosaicDataUpSet(assay_list, plot = FALSE, ...)"},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataUpSet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mosaicDataUpSet — mosaicDataUpSet","text":"assay_list list data matrices rownames (features) specified. plot logical (default FALSE) whether UpSet plot printed. ... arguments passed `upset` `UpSetR` package.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataUpSet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mosaicDataUpSet — mosaicDataUpSet","text":"UpSet object displaying degree overlap rownames (features) among data matrices assay_list. Set bars correspond number cells/samples present data matrix.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/mosaicDataUpSet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"mosaicDataUpSet — mosaicDataUpSet","text":"","code":"set.seed(2021) assay_list <- mockMosaicData() lapply(assay_list, dim) #> $D1 #> [1] 150  50 #>  #> $D2 #> [1] 150  50 #>  #> $D3 #> [1] 150  50 #>  mosaicDataUpSet(assay_list)   # additional arguments from UpSetR::upset() mosaicDataUpSet(assay_list, empty.intersections = TRUE)"},{"path":"https://sydneybiox.github.io/StabMap/reference/queryNamedKNN.html","id":null,"dir":"Reference","previous_headings":"","what":"queryNamedKNN — queryNamedKNN","title":"queryNamedKNN — queryNamedKNN","text":"queryNamedKNN","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/queryNamedKNN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"queryNamedKNN — queryNamedKNN","text":"","code":"queryNamedKNN(coords_reference, coords_query, k)"},{"path":"https://sydneybiox.github.io/StabMap/reference/queryNamedKNN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"queryNamedKNN — queryNamedKNN","text":"coords_reference coords_reference coords_query coords_query k k","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/queryNamedKNN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"queryNamedKNN — queryNamedKNN","text":"matrix","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/reWeightEmbedding.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-weight StabMap embedding — reWeightEmbedding","title":"Re-weight StabMap embedding — reWeightEmbedding","text":"Re-weights embedding according given weights reference dataset. gives less weighting contributing dataset method (PCA LDA),","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/reWeightEmbedding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-weight StabMap embedding — reWeightEmbedding","text":"","code":"reWeightEmbedding(embedding, weights = NULL, factor = 1e+06)"},{"path":"https://sydneybiox.github.io/StabMap/reference/reWeightEmbedding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-weight StabMap embedding — reWeightEmbedding","text":"embedding Joint embedding output stabMap. weights (optional) named numeric vector giving relative weights reference dataset. factor numeric multiplicative value offset near-zero values.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/reWeightEmbedding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-weight StabMap embedding — reWeightEmbedding","text":"matrix dimensions `embedding`.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/reWeightEmbedding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Re-weight StabMap embedding — reWeightEmbedding","text":"","code":"set.seed(2021) assay_list <- mockMosaicData() lapply(assay_list, dim) #> $D1 #> [1] 150  50 #>  #> $D2 #> [1] 150  50 #>  #> $D3 #> [1] 150  50 #>   # specify which datasets to use as reference coordinates reference_list <- c(\"D1\", \"D3\")  # specify some sample labels to distinguish using linear discriminant # analysis (LDA) labels_list <- list(   D1 = rep(letters[1:5], length.out = ncol(assay_list[[\"D1\"]])) )  # stabMap out <- stabMap(assay_list,   reference_list = reference_list,   labels_list = labels_list,   ncomponentsReference = 20,   ncomponentsSubset = 20 ) #> treating \"D1\" as reference #> generating embedding for path with reference \"D1\": \"D1\" #> generating embedding for path with reference \"D1\": \"D2\" -> \"D1\" #> generating embedding for path with reference \"D1\": \"D3\" -> \"D2\" -> \"D1\" #> labels provided for \"D1\", adding LD components #> generating embedding for path with reference \"D1\": \"D1\" #> generating embedding for path with reference \"D1\": \"D2\" -> \"D1\" #> generating embedding for path with reference \"D1\": \"D3\" -> \"D2\" -> \"D1\" #> treating \"D3\" as reference #> generating embedding for path with reference \"D3\": \"D3\" #> generating embedding for path with reference \"D3\": \"D2\" -> \"D3\" #> generating embedding for path with reference \"D3\": \"D1\" -> \"D2\" -> \"D3\"   # look at the scale of each component and discriminant boxplot(out, las = 2, outline = FALSE)   # re-weight embedding for less contribution from LDs and equal contribution # from PCs of both references out_reweighted <- reWeightEmbedding(   out,   weights = c(\"D1_LD\" = 0.5, \"D1_PC\" = 1, \"D3_PC\" = 1) ) #> reweighting for references: D1_LDD1_PCD3_PC  # look at the new scale of each component and discriminant boxplot(out_reweighted, las = 2, outline = FALSE)"},{"path":"https://sydneybiox.github.io/StabMap/reference/selectFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"selectFeatures — selectFeatures","title":"selectFeatures — selectFeatures","text":"given assay set features, perform variance ranking select subset features","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/selectFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"selectFeatures — selectFeatures","text":"","code":"selectFeatures(assay, features, maxFeatures)"},{"path":"https://sydneybiox.github.io/StabMap/reference/selectFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"selectFeatures — selectFeatures","text":"assay assay matrix rows features, columns cells features Character vector current features selected maxFeatures Integer number maxFeatures select","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/selectFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"selectFeatures — selectFeatures","text":"character vector selected features according variance ranking.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/smoothLocal.html","id":null,"dir":"Reference","previous_headings":"","what":"smoothLocal — smoothLocal","title":"smoothLocal — smoothLocal","text":"Smooth adaptive k values. Can smoothed computing arithmetic geometric mean adaptive k-values cells neighbourhood","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/smoothLocal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"smoothLocal — smoothLocal","text":"","code":"smoothLocal(best_k, local, smooth = 10, mean_type = \"geometric\")"},{"path":"https://sydneybiox.github.io/StabMap/reference/smoothLocal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"smoothLocal — smoothLocal","text":"best_k named vector local best k values local KNN matrix, rows best_k values indices best_k. smooth integer k-nearest neighbours smooth . mean_type Character indicating calculate 'geometric' 'arithmetic' mean.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/smoothLocal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"smoothLocal — smoothLocal","text":"numeric vector smoothed adaptive k-values.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/stabMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Stabilised mosaic single cell data integration using unshared features — stabMap","title":"Stabilised mosaic single cell data integration using unshared features — stabMap","text":"stabMap performs mosaic data integration first building mosaic data topology, reference dataset, traverses topology project predict data onto common principal component (PC) linear discriminant (LD) embedding.","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/stabMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stabilised mosaic single cell data integration using unshared features — stabMap","text":"","code":"stabMap(   assay_list,   labels_list = NULL,   reference_list = NULL,   reference_features_list = lapply(assay_list, rownames),   reference_scores_list = NULL,   ncomponentsReference = 50,   ncomponentsSubset = 50,   suppressMessages = TRUE,   projectAll = FALSE,   restrictFeatures = FALSE,   maxFeatures = 1000,   plot = TRUE,   scale.center = TRUE,   scale.scale = TRUE,   SE_assay_names = \"logcounts\",   BPPARAM = SerialParam(),   verbose = TRUE )"},{"path":"https://sydneybiox.github.io/StabMap/reference/stabMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stabilised mosaic single cell data integration using unshared features — stabMap","text":"assay_list list data matrices rownames (features) specified. labels_list (optional) named list containing cell labels reference_list Named list containing logical values whether data matrix considered reference dataset, alternatively character vector containing names reference data matrices. NULL, defaults :  sapply(names(assay_list), function(x) TRUE, simplify = FALSE) reference_features_list List features consider reference data (default available features). reference_scores_list Named list reference scores (default NULL). provided, matrix cells (rows rownames given) dimensions (columns colnames given) used reference low-dimensional embedding target, opposed performing PCA LDA input reference data. ncomponentsReference Number principal components embedding reference data, given either integer named list reference dataset. ncomponentsSubset Number principal components embedding query data prior projecting reference, given either integer named list reference dataset. suppressMessages Logical whether suppress messages (default TRUE). projectAll Logical whether re-project reference data along query (default FALSE). restrictFeatures logical whether restrict features used dimensionality reduction reference data (default FALSE). Overall recommended FALSE single-hop integrations TRUE multi-hop integrations. maxFeatures Maximum number features consider predicting principal component scores (default 1000). plot Logical whether plot mosaic data UpSet plot mosaic data topology networks (default TRUE). scale.center Logical whether re-center data mean 0 (default FALSE). scale.scale Logical whether re-scale data standard deviation 1 (default FALSE). SE_assay_names Either string indicating name assays SummarizedExperiment objects assay_list named list assay names, names corrispond names SE objects assay_list (default \"logcounts\") BPPARAM BiocParallelParam object specifying parallelisation performed verbose Logical whether console output provided (default TRUE)","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/stabMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stabilised mosaic single cell data integration using unshared features — stabMap","text":"matrix containing common embedding rows corresponding cells, columns corresponding PCs LDs reference dataset(s).","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/stabMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stabilised mosaic single cell data integration using unshared features — stabMap","text":"","code":"set.seed(2021) assay_list <- mockMosaicData() lapply(assay_list, dim) #> $D1 #> [1] 150  50 #>  #> $D2 #> [1] 150  50 #>  #> $D3 #> [1] 150  50 #>   # specify which datasets to use as reference coordinates reference_list <- c(\"D1\", \"D3\")  # specify some sample labels to distinguish using linear discriminant # analysis (LDA) labels_list <- list(   D1 = rep(letters[1:5], length.out = ncol(assay_list[[\"D1\"]])) )  # examine the topology of this mosaic data integration mosaicDataUpSet(assay_list)  plot(mosaicDataTopology(assay_list))   # stabMap out <- stabMap(assay_list,   reference_list = reference_list,   labels_list = labels_list,   ncomponentsReference = 20,   ncomponentsSubset = 20 ) #> treating \"D1\" as reference #> generating embedding for path with reference \"D1\": \"D1\" #> generating embedding for path with reference \"D1\": \"D2\" -> \"D1\" #> generating embedding for path with reference \"D1\": \"D3\" -> \"D2\" -> \"D1\" #> labels provided for \"D1\", adding LD components #> generating embedding for path with reference \"D1\": \"D1\" #> generating embedding for path with reference \"D1\": \"D2\" -> \"D1\" #> generating embedding for path with reference \"D1\": \"D3\" -> \"D2\" -> \"D1\" #> treating \"D3\" as reference #> generating embedding for path with reference \"D3\": \"D3\" #> generating embedding for path with reference \"D3\": \"D2\" -> \"D3\" #> generating embedding for path with reference \"D3\": \"D1\" -> \"D2\" -> \"D3\"   head(out) #>               D1_PC1     D1_PC2     D1_PC3       D1_PC4      D1_PC5     D1_PC6 #> D1_cell_1  2.6270969 -3.1709928  4.0506445 -3.609130459  1.43056606 -2.5013943 #> D1_cell_2 -4.5057485  0.5752083  0.8340238 -1.014823114  0.63151929 -1.4937527 #> D1_cell_3  0.6226309 -1.5472376  2.6103086 -0.018643114 -2.81536539 -1.0940201 #> D1_cell_4 -4.2263350 -2.0444978 -0.5356968 -3.453648014  2.92566847  0.2716939 #> D1_cell_5  3.8947019  0.9106738 -3.6039996  0.004893567 -2.30739074 -0.3341585 #> D1_cell_6  2.0177813  3.5252245 -4.1753395 -1.148906355  0.05251646  1.8700432 #>                D1_PC7     D1_PC8     D1_PC9    D1_PC10    D1_PC11    D1_PC12 #> D1_cell_1  0.24764751  0.5873167 -2.3067376  3.2015090 -0.4526165 -1.2460048 #> D1_cell_2  0.25444661 -0.7616007 -2.4968763  0.1378678  2.8105718  4.8446448 #> D1_cell_3 -0.03710635  1.5760269 -0.3924504  1.1906449 -3.6871124 -3.7681881 #> D1_cell_4  1.69233366  0.7617611  4.8401743 -2.0105921 -1.1875114 -1.5079628 #> D1_cell_5  4.31581421  0.9061911 -0.9850855  1.2802993 -1.6064210  0.3283823 #> D1_cell_6 -3.75335901 -0.4612008 -2.3790983  1.2309207 -2.1421033 -0.9491438 #>              D1_PC13   D1_PC14   D1_PC15     D1_PC16    D1_PC17    D1_PC18 #> D1_cell_1 -3.1375299  4.378068 -3.444451 -1.78898621  2.2372443  0.7444908 #> D1_cell_2 -0.7939143  2.721340 -0.377106 -0.09414872 -1.4999731 -4.7338701 #> D1_cell_3  0.4814744 -3.724470 -1.594450 -1.49311501 -1.9097362 -1.1429568 #> D1_cell_4 -3.0741564  1.146310  1.966764  2.49615083  1.8948504 -0.2249584 #> D1_cell_5 -0.2501072 -1.337008  1.229278 -2.45020979 -0.6301791 -1.0275208 #> D1_cell_6  1.9202294 -1.207617  2.005668 -0.81970304  1.8491050  0.7083563 #>              D1_PC19    D1_PC20     D1_LD1    D1_LD2     D1_LD3      D1_LD4 #> D1_cell_1  1.2420356 -2.6537437 -0.3927678 -1.674139 -1.1392196  0.01773841 #> D1_cell_2  1.5838926 -0.7553650  1.2724435  0.793653  1.1154764  1.00840563 #> D1_cell_3 -2.0095487 -1.4511791 -1.4536953  1.599853 -0.9361014  0.06013095 #> D1_cell_4 -0.2146626  1.1997056  1.1922330 -1.336241 -0.0218638  0.50445480 #> D1_cell_5  2.5546764 -2.1599689 -1.8890462 -1.191700 -0.1356699  0.66198248 #> D1_cell_6 -1.4360245 -0.1285278  0.1478705 -1.261443  0.7427569 -0.93665942 #>               D3_PC1     D3_PC2     D3_PC3     D3_PC4    D3_PC5    D3_PC6 #> D1_cell_1  -5.092261 -8.2508106  -3.425651  0.4690352 -1.364690  2.321041 #> D1_cell_2 -12.595956 -0.2080118  14.737664  6.5019626 -2.625472  5.032621 #> D1_cell_3  11.306185  1.9951329 -19.052218 -7.5799107  4.386649 -7.594878 #> D1_cell_4  23.365322  2.8256687  -6.699824 -3.8222222 12.100088 -2.068096 #> D1_cell_5   3.486375 -1.6333790 -12.325699 -6.0603731 -6.831641 -1.613613 #> D1_cell_6   4.529259 -2.8107622  -5.415551 12.4524323  4.605050 -3.963519 #>               D3_PC7     D3_PC8     D3_PC9    D3_PC10   D3_PC11    D3_PC12 #> D1_cell_1  3.8764270  4.0883336  -2.428012   0.777225  2.710615 -2.2746418 #> D1_cell_2  3.6141002  6.0370627   9.409343   7.649837 -7.823011 -0.9906947 #> D1_cell_3 -2.5210622 -4.6332622  -9.397545 -12.032917 10.564143  2.8743073 #> D1_cell_4 -0.1166204  0.9251495 -12.568801  -9.028202  1.519507 -0.4224104 #> D1_cell_5 -7.9823973 -5.9523726  -9.895665  -3.196059 12.193287  0.4332797 #> D1_cell_6  9.7299622  3.6624287   2.562550   2.438239 -2.061845  3.2577935 #>              D3_PC13    D3_PC14    D3_PC15     D3_PC16   D3_PC17   D3_PC18 #> D1_cell_1 -0.8287253   2.576194  -1.231400  -2.2388515  1.976501  5.664104 #> D1_cell_2  6.5423034  -7.724872   4.553026  14.3713414 -8.397892 -2.623366 #> D1_cell_3 -7.2103254  13.081504  -4.107559 -17.0461472 10.751740  1.107026 #> D1_cell_4 -9.1727975  -3.286657 -11.690377  -4.8885937 -6.230477  2.364442 #> D1_cell_5 -1.9820459  14.167342   1.655575  -9.5230610 12.926554  2.182250 #> D1_cell_6 -3.3057188 -14.400471  -8.922535   0.4140863  4.918437 -2.660325 #>              D3_PC19    D3_PC20 #> D1_cell_1 -1.6946016  -2.072674 #> D1_cell_2  4.6159188  -2.637280 #> D1_cell_3 -7.0317522   5.098998 #> D1_cell_4  0.6198541 -14.316265 #> D1_cell_5 -7.6733369  10.684121 #> D1_cell_6  2.0122155  -5.141146"},{"path":"https://sydneybiox.github.io/StabMap/reference/vectorSubset.html","id":null,"dir":"Reference","previous_headings":"","what":"vectorSubset — vectorSubset","title":"vectorSubset — vectorSubset","text":"vectorSubset","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/vectorSubset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"vectorSubset — vectorSubset","text":"","code":"vectorSubset(vec, mat)"},{"path":"https://sydneybiox.github.io/StabMap/reference/vectorSubset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"vectorSubset — vectorSubset","text":"vec vec mat mat","code":""},{"path":"https://sydneybiox.github.io/StabMap/reference/vectorSubset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"vectorSubset — vectorSubset","text":"matrix","code":""},{"path":"https://sydneybiox.github.io/StabMap/news/index.html","id":"stabmap-0993","dir":"Changelog","previous_headings":"","what":"StabMap 0.99.3","title":"StabMap 0.99.3","text":"verbose argument stabMap number PCs automatically selected mean set 0 modelGeneVar maxFeatures argument used stabMap UpSetR moved depends suggests","code":""}]
